@[TOC](模块化开发)

# 模块化概述

当下最重要的前端开发范式之一。模块化只是一个思想、一个理论。

内容概要

## 模块化演变过程

早期模块化完全依靠约定。

* 1，文件划分方式

  **缺点：**

  污染全局作用域

  命名冲突问题

  无法管理模块依赖关系

* 2，命名空间方式

  将所需变量包裹进全局对象内

* 3，IIFE

  将变量私有成员

## 模块化规范

模块化标准 + 模块加载器

### CommonJs 规范

CommonJs 是针对 NodeJs 的规范，是以同步模式加载模块，约定如下：

* 1，一个文件就是一个模块
* 2，每个模块都有单独的作用域
* 3，通过 module.exports 导出成员
* 4，通过 require 函数载入模块

### AMD + Require.js 

AMD(Asynchronous Module Definition)，异步的模块定义规范，是针对浏览器的规范，它是通过 Require.js 进行实现的，Require.js 是一个非常强大的模块加载器。

**缺点**

* 1，AMD 使用起来相对复杂；
* 2，模块 JS 文件请求频繁

#### Require.js API

##### define()

每一个模块都要通过 define() 函数进行定义。

* 传递三个参数

  第一个参数，是一个字符串，表示模块名，方便后期通过模块名进行使用；

  第二个参数，是一个数组，用来声明这个模块的一些依赖项，此参数按需添加，可有可无；

  第三个参数，是一个函数，函数的参数与前面数组中的依赖项一一对应，每一项分别为依赖项导出的成员，用来为当前模块提供私有空间，通过 return 向外部导出成员

  <font color="#999999">语法示例如下：</font>

  ```javascript
  define('module_name', [], function() { return ... })
  ```

##### require()

require() 函数，用来载入一个模块，内部会自动创建script标签，执行相应的代码。

* 传入两个参数

  第一个参数，是一个数组，表示所引入模块的组合

  第二个参数，是一个函数，函数的参数与前面数组中的模块一一对应，可以使用 **模块名.xx** 的方式访问模块中导出的成员

  <font color="#999999">语法示例如下：</font>

  ```javascript
  require(['module_name', ...], function(module_name){
     // module_name.xx 
  })
  ```

### CMD + Sea.js

CMD(Common Module Definition)，通用的模块定义规范，类似 CommonJs 规范。Sea.js 是由淘宝推出的库，遵循CMD规范。

### ES Modules

ES Modules 规范 是在 ECMAScript2015(ES6)中提出的 Module 模块标准。通过给 script 添加 type = module 的属性，就可以以 **ES Module** 的标准执行其中的 JS 代码。

#### 基本特性

* 1，ESM 自动采用严格模式，忽略 'use strict' 

  ```html
  <script type="module">
      console.log(this); // undefined this在严格模式下，为 undefined
  </script>
  ```

* 2，每个 ES Module 都是运行在单独的私有作用域中

  ```html
  <script type="module">
      var foo = 100   // 不会造成全局作用域污染问题
      console.log(foo) // 100
  </script>
  <script type="module">
      console.log(foo) // Uncaught ReferenceError: foo is not defined
  </script>
  ```

* 3，ESM 是通过 CORS 的跨域请求方式请求外部 JS 模块的

  ```html
  <script type="module" src="https://umpkg.com/jquery@3.4.1/dist/jquery.min.js"> 		// 需要服务端支持 CORS ，否则会出现跨域问题
  </script>
  ```

- 4，ESM 的 script 标签会延迟执行脚本，相当于 script 的 defer 属性

  ```html
  <script type="module" src="./demo.js">
      // 等待网页的渲染过后，再去执行脚本，不会阻碍页面的显示
  </script>
  <p>需要显示的内容</p>
  ```

#### 导入和导出

##### 导出 (export)

export 是在模块内去对外暴露接口。

**导出语法**

* 1，**直接成员导出**，变量、函数、类等都可以导出。

  <font color="#999999">导出方式如下：</font>

  ```javascript
  export var name = 'foo module'   // 导出变量
  
  export function hello () { }     // 导出函数
  
  export class Person { }          // 导出类  
  ```

* 2，**成员集中导出**，可以更加直观的看到向外部导出了哪些成员

  导出方式如下：</font>

  ```javascript
  var name = 'foo module'
  function hello () { }
  class Person { }
  
  export { name, hello, Person }
  ```

* 3，**别名导出**，使用 as 进行重命名

  导出方式如下：</font>

  ```javascript
  var name = 'foo module'
  function hello () { }
  class Person { }
  
  export { name as fooName, hello as fooHello, Person as fooPerson }
  ```

* 4，**默认导出**，设置某一个成员的别名是 default

  导出方式如下：</font>

  ```javascript
  var name = 'foo module'
  
  export { name as default }
  // <==> 推荐下方书写方式
  export default name
  ```

##### 导入 (import)

import 是在模块内导入其他模块所提供的接口。

**导入语法**

对应上面的导出语法。

* 1，对应 **直接成员导出 和 成员集中导出**

  <font color="#999999">导入方式如下：</font>

  ```javascript
  import { name, hello, Person } from 'module_path' // .js 不可以省略，完整路径
  ```

* 2，对应 **别名导出**

  <font color="#999999"> 导入方式如下(app.js)：</font>

  ```javascript
  import { fooName, fooHello, fooPerson } from 'module_path'
  ```

* 3，对应 **默认导出**

  <font color="#999999"> 导入方式如下(app.js)：</font>
  
  ```javascript
  import { default as name }  from 'module_path' // default 是关键字
  // 简写为
  import name from 'module_path'
  ```

* 4，导入模块时，模块路径的三种写法

  <font color="#999999"> 模块路径如下(app.js)：</font>

  ```javascript
  // ./ 不可以省略，相对路径
  import { name } from './module.js'
  
  // / 绝对路径
  import { name } from '/04-import/module.js'
  
  // 完整 url 路径
  import { name } from 'htto://localhost:3000//04-import/module.js'
  ```

* 5， 加载模块，但不提取模块内的成员，一般用于导入一些不需要外部控制的子功能模块

  <font color="#999999"> 导入示例如下(app.js)：</font>

  ```javascript
  import {} from './module.js'
  // 简写为
  import './module.js'
  ```

* 6，提取模块导出的所有成员, 使用 as 将所有成员作为一个对象的属性

  <font color="#999999"> 导入示例如下(app.js)：</font>

  ```javascript
  import * as mod from './module.js'
  console.log(mod.name, mod.age);
  ```

* 7，动态导入模块, 返回一个 Promise对象

  <font color="#999999"> 导入示例如下(app.js)：</font>

  ```javascript
  import('./module.js').then(function (module) {
      console.log(module);
  })
  ```

* 8，导出时，同时导出命名成员和默认成员，如何导入

  <font color="#999999"> 导入示例如下(app.js)：</font>

  ```javascript
  import { name, age, default as d } from './module.js'
  // 简写为, 默认成员的名字可以随意命名
  import d, { name, age } from './module.js'
  ```

##### 导出导入成员

当前 module.js 模块的导出成员，将直接作为 app.js 模块的导出成员使用，一般用于集中导出分散的子模块成员

* 1，index.js ，集中导出成员文件

  ```javascript
  export { Button } from './button.js'
  
  // 默认成员的导出，必须重命名，以别名的形式导出
  export { default as Avatar} from './avatar.js'
  ```

* 2，button.js ，分散子模块，导出 Button 成员

  ```javascript
  export var Button = 'Button Component'
  ```

* 3，avatar.js ，分散子模块，导出 Avatar 默认成员

  ```javascript
  var  Avatar  = 'Avatar Component'
  export default Avatar
  ```

##### 注意事项

* 1，export 单独使用时， <font color="#ff0000">{}</font> 是固定语法，导出的不是对象字面量

  <font color="#999999">代码示例如下：</font>

  ```javascript
  var name = 'jack'
  var age = 18
  
  export { name, age } 
  ```

  导入模块，<font color="#ff0000">{}</font> 固定语法，不是对象的解构

  <font color="#999999">代码示例如下：</font>

  ```javascript
  import { name, age } from './module.js'
  ```

* 2，export default 组合使用时，<font color="#ff0000">{}</font> 代表导出的是对象字面量

  <font color="#999999">代码示例如下：</font>

  ```javascript
  var name = 'jack'
  var age = 18
  
  export default { name, age }
  ```

  导入模块，**不可以**使用 {} 写法

  <font color="#999999">代码示例如下：</font>

  ```javascript
  // module_obj 自定义名字，最好和模块名保持一致
  import module_obj from './module.js' 
  
  // 访问导出的成员
  console.log(module_obj.name, module_obj.age)
  ```

* 3，export 导出的是值的**内存地址**

  <font color="#999999">代码示例如下(module.js)：</font>

  ```javascript
  var name = 'jack'
  var age = 18
  
  export { name, age } // 导出的是值的内存地址
  
  setTimeout(function () {
      name = 'ben'
  }, 1000)
  ```

  <font color="#999999">代码示例如下(app.js)：</font>

  ```javascript
  import { name, age } from './module.js'
  
  console.log(name, age);  // jack 18
  
  setTimeout(function () {
      console.log(name, age); // ben 18
  }, 1500)
  ```

* 4，导出的值是只读的，无法在模块外部修改成员

  <font color="#999999">代码示例如下(app.js)：</font>

  ```javascript
  import { name, age } from './module.js'
  
  name = 'tom' // Uncaught TypeError: Assignment to constant variable.
  ```

#### Polyfill

解决浏览器的兼容性问题

* 在 HTML 页面，手动引入 browser-es-module-loader

  js 文件查找地址，如下：[browser-es-module-loader ](https://unpkg.com/browse/browser-es-module-loader@0.4.1/dist/)

  <font color="#999999">代码示例如下(app.js)：</font>

  ```html
  <!-- 有的IE版本不支持 Promise，因此需要引入 Promise Polyfill -->
  <script nomodule src="https://unpkg.com/promise-polyfill@8.2.0/dist/polyfill.min.js"></script>
  <!-- babel 即时运行在浏览器上的版本 -->
  <script nomodule src="https://unpkg.com/browser-es-module-loader@0.4.1/dist/babel-browser-build.js"></script>
  <!-- ES Modules Loader, 读取代码，将不识别的特性交给 babel 进行转换 -->
  <script nomodule src="https://unpkg.com/browser-es-module-loader@0.4.1/dist/browser-es-module-loader.js"></script>
  ```

  **nomodule 属性**，表示只在不支持 ES Modules 的浏览器中运行，避免支持的浏览器多次运行 。

  **<font color="#ff00000">不建议在生产版本中使用，影响效率</font>**

#### in Node.js

* **测试 ES Modules 在 node.js 环境的运行情况**

  文件后缀名，设置为 **xxx.mjs**

  添加参数 -- experimental-modules ， 启动 ES Modules 的实验特性

  ```powershell
  $ node --experimental-modules xxx.mjs # node 8.5+
  ```

  1）内置模块兼容了 ESM 的提取成员方式

  <font color="#999999">引入方式如下(index.mjs)：</font>

  ```javascript
  // 方式一
  import fs from 'fs'
  fs.writeFileSync('./foo.txt', 'es module working') // 代码执行成功
  
  // 方式二
  import { writeFileSync } from 'fs'
  writeFileSync('./bar.txt', 'es module working~') // 代码执行成功
  ```

  2）第三方模块都是导出默认成员，不支持使用 {} 语法导入成员

  <font color="#999999">引入方式如下(index.mjs)：</font>

  ```javascript
  import _ from 'lodash'
  console.log(_.camelCase('ES Module')); // 代码执行成功
  
  // import { camelCase } from 'lodash'
  // console.log(camelCase('ES Module')); // SyntaxError:...
  ```

* **ES Modules 与 CommonJS 交互**

  1）ES Modules 中可以导入 CommonJS 模块

  <font color="#999999">代码示例如下（commonJs.js）：</font>

  ```javascript
  module.exports = {
      foo: 'commonjs'
  }
  // exports 是 module.exports 的别名，二者是等价的
  exports.foo = 'commonjs'
  ```

  <font color="#999999">代码示例如下（es-modules.mjs）：</font>

  ```javascript
  import mod from './common.js'
  console.log(mod);
  ```

  2）CommonJS 中不能导入 ES Modules 模块

  <font color="#999999">代码示例如下（commonJs.js）：</font>

  ```javascript
  // const mod = require('./es-module.mjs')
  // console.log(mod); // Error [ERR_REQUIRE_ESM]: Must use import to load ES Module
  ```

  <font color="#999999">代码示例如下（es-modules.mjs）：</font>

  ```javascript
  export const foo = 'es module export value'
  ```

  3）CommonJS 始终只会导出一个默认成员，不能直接提取成员

  <font color="#999999">代码示例如下（commonJs.js）：</font>

  ```javascript
  exports.foo = 'commonjs'
  ```

  <font color="#999999">代码示例如下（es-modules.mjs）：</font>

  ```javascript
  // import { foo } from './common.js' // SyntaxError:...
  // console.log(foo);
  ```

  4）注意 import 不是解构导出对象

* **ES Modules 与 CommonJs 的差异**

  ES Modules 中没有 CommonJs 中的那些模块全局成员了，如：

  > require（加载模块函数）；
  >
  > module（模块对象）；
  >
  > exports（导出对象别名）；
  >
  > __filename（当前文件的绝对路径）；
  >
  > __dirname（当前文件所在目录）

* **node.js 新版本进一步支持**

  为了使项目中所有的js文件，都可以使用 ES Modules ，在 package.json 中添加属性 type 进行设置。

  <font color="#999999">代码示例如下（package.json）：</font>

  ```json
  {
      type: 'module'
  }
  ```

  此时，无需再将 .js 改为 .mjs。但是要将 CommonJS 的 .js 改为 .cjs，保证兼容 CommonJS。

* **低版本 Node.js，使用 Babel 进行兼容**

  1）安装 babel 相关依赖模块

  ```powershell
  $ yarn add @babel/node @babel/core @babel/preset-env --dev
  ```

  2）运行 ES Modules 的 JS 文件，需要添加特性转换的预设参数

  ```powershell
  $ yarn babel-node index.js --presets=@babel/preset-env
  ```

  3）@babel/preset-env 只是一个插件集合，真正起作用的是 @babel/plugin-transform-modules-commonjs 插件

  ```powershell
  $ yarn add @babel/plugin-transform-modules-commonjs --dev
  ```

  4）若不想在执行命令时添加参数，可以配置 .babelrc 文件，这是 babel 的配置文件

  <font color="#999999">代码示例如下（.babelrc）：</font>

  ```json
  {
      "presets": ["@babel/preset-env"],
      "plugins": ["@babel/plugin-transform-modules-commonjs"]
  }
  ```

  5）运行命令，进行测试

  ```powershell
  $ yarn babel-node index.js
  ```

### 总结

模块化的最佳实践：NodeJs 环境遵循 CommonJs，浏览器环境遵循 ES Modules 规范。

# 模块打包工具

打包工具解决的是前端整体的模块化，并不单指 JavaScript 模块化。

**产生原因**

* ES Modules 存在环境兼容问题
* 模块文件过多，网络请求频繁
* 所有的前端资源都需要模块化

## Webpack

### 基本介绍

 webpack，常用的模块打包器(Module bundler)，可以将零散的JavaScript 代码打包到一个 JS 文件中。对于那些存在环境兼容问题的代码，可以在打包过程中通过模块加载器(Loader)对其进行编译转换。他还具有代码拆分(Code Splitting)的能力，他可以将所有的代码都按照我们的需要进行打包，可以实现渐进式的打包方式。

### 快速上手

* 1，准备三个文件，本次使用 http-server 构建服务器，也可以采用其他的

  <font color="#999999">代码示例如下（heading.js）：</font>

  ```javascript
  export default () => {
      const elemnet = document.createElement('h2')
  
      elemnet.textContent = 'hello world'
      elemnet.addEventListener('click', () => {
          alert('Hello webpack')
      })
  
      return elemnet
  }
  ```

  <font color="#999999">代码示例如下（index.js）：</font>

  ```javascript
  import createHeading from './heading.js'
  
  const heading = createHeading()
  
  document.body.append(heading)
  ```

  <font color="#999999">代码示例如下（index.html）：</font>

  ```html
   <script type="module" src="./src/index.js"></script>    
  ```

* 2，webpack 是一个 NPM 工具模块，需要初始化包管理文件 package.json

  ```powershell
  $ yarn init --yes # or npm init -y
  ```

* 3，安装 webpack核心模块 ，以及对应的 webpack-cli模块

  ```powershell
  $ yarn add webpack webpack-cli --dev # or npm i webpack webpack-cli --save-dev
  ```

* 4，查看 webpack 是否安装成功

  ```powershell
  $ yarn webpack --version
  ```

  运行结果，如下图所示：

  ![查看webpack 版本](C:\Users\li_sh\AppData\Roaming\Typora\typora-user-images\image-20201126160628385.png)

* 5，使用 webpack ，进行打包

  ```powershell
  $ yarn webpack
  ```

  运行结果，如下图所示：

  ![打包成功](C:\Users\li_sh\AppData\Roaming\Typora\typora-user-images\image-20201126161151819.png)

  可以看到，打包后，会生成一个 dist 文件夹，里面包含一个 main.js

* 6，在 package.json 中，使用 NPM Scripts 对打包命令进行包装

  <font color="#999999">配置代码如下：</font>

  ```json
  {
      "scripts": {
          "build": "webpack"
      }
  }
  ```

* 7，将 index.html 中引入的 js，进行修改

  <font color="#999999">代码示例如下（index.html）：</font>

  ```html
  <script src="dist/main.js"></script>    
  ```

### 基本使用

webpack 4.0+ 支持按照约定的内容，进行打包，即

`src/index.js`(默认入口文件)  打包到 `dist/main.js`

#### 配置文件

在项目根目录添加 webpack.config.js 配置文件。

##### 工作模式

* development（开发模式），优化打包的速度

  ```powershell
  $ yarn webpack --mode development
  ```

* production（生产模式），启动多个插件，进行代码的压缩等

  ```powershell
  $ yarn webpack --mode production
  ```

* none，运行最原始状态的打包，不会做任何的处理

  ```powershell
  $ yarn webpack --mode none
  ```

##### 基本配置

* 指定 webpack 打包的入口文件    

  <font color="#999999">配置代码如下（webpack.config.js）：</font>

  ```js
  module.exports = {
      entry: './src/main.js' // 相对路径时，./ 不能省略
  }
  ```

* 设置输出文件的位置

  <font color="#999999">配置代码如下（webpack.config.js）：</font>

  ```js
  const path = require('path')
  module.exports = {
      output: {
          filename: 'bundle.js', // 设置输出文件的名称
          // 指定输出文件所在的目录，必须是绝对路径
          // 利用 node 的 path 模块，组合生成绝对路径
          path: path.join(__dirname, 'output')     
      }
  }
  ```

* 配置打包的工作模式 值为：development | production | none 

  <font color="#999999">配置代码如下（webpack.config.js）：</font>

  ```js
  module.exports = {
      mode: 'development',
  }
  ```

##### Loader

Loader 是 webpack 的核心特性，借助于 Loader 就可以加载任何类型的资源，从而实现资源模块加载的功能。

然而，webpack 内部内置的 loader 只能对 JS 文件进行打包，其他的资源文件需要引入其他的 loader 进行处理，最终都会转换成 js 模块。

###### css-loader

对 css 文件进行转换的加载器，将资源文件转换成 js 代码。

* 1，安装 loader 模块

  ```powershell
  $ yarn add css-loader --dev # or npm i css-loader --save-dev
  ```

* 2，在 css 文件中，书写 body 的样式

  <font color="#999999">样式代码如下（main.css）：</font>

  ```css
  body {
      margin: 0 auto;
      padding: 0 20px;
      max-width: 800px;
      background-color: #000000;
  }
  ```

* 3，在 webpack.config.js 中进行配置

  <font color="#999999">配置代码如下（webpack.config.js）：</font>

  ```js
  module.exports = {
      entry: './src/main.css',
      module: {
          rules: [  // rules 数组，是指针对其他资源模块的加载规则的配置
              {   
                  test: /\.css$/,  // 正则表达式，用来匹配在打包过程中遇到的文件路径
                  use: 'css-loader' // 用来指定匹配到的文件，需要去使用的 loader
              }
          ]
      }
  }
  ```

  页面效果，如下图所示：

  ![image-20201127082401231](C:\Users\li_sh\AppData\Roaming\Typora\typora-user-images\image-20201127082401231.png)

  可以看到，此时页面中并没有对应的样式。这是因为还需要 style-loader 将转换后的结果追加到页面中。

###### style-loader

把 css-loader 转换后的结果，通过 style 标签的形式追加到页面中。

* 1，安装 loader 模块

  ```powershell
  $ yarn add style-loader --dev # or npm i style-loader --save-dev
  ```

* 2，修改 webpack.config.js 中的配置

  <font color="#999999">配置代码如下（webpack.config.js）：</font>

  ```js
  module.exports = {
      entry: './src/main.css',
      module: {
          rules: [ // rules数组，是指针对其他资源模块的加载规则的配置
              {   
                  test: /\.css$/, // 正则表达式，用来匹配在打包过程中遇到的文件路径
                  // 用来指定匹配到的文件，需要去使用的 loader
                  use: [ // 若配置多个loader，执行顺序是 从后往前 的
                      'style-loader', 
                      'css-loader'   // 先将 css 代码转换成 js 模块
                  ]
              }
          ]
      }
  }
  ```

###### file-loader

文件资源加载器，这里主要指图片、字体等资源。

* 1，安装 loader 模块

  ```powershell
  $ yarn add file-loader --dev # or npm i file-loader --save-dev
  ```

* 2，在 main.js 引入图片

  <font color="#999999">代码示例如下（main.js）：</font>

  ```js
  import createHeading from './heading.js'
  import './main.css'
  import u from './u0.png'
  
  const heading = createHeading()
  document.body.append(heading)
  
  const img = new Image()
  img.src = u
  document.body.append(img)
  ```

* 3，在 webpack.config.js 中添加配置规则

  <font color="#999999">配置代码如下（webpack.config.js）：</font>

  ```js
  module.exports = {
      output: {
          filename: 'main.js',
          path: path.join(__dirname, 'dist'),
          publicPath: 'dist/'  // 设置网站的根目录  / 不能省略，默认为 ''
      },
      module: {
          rules: [
              {   // 配置图片规则
                  test: /\.png$/, 
                  use: 'file-loader'
              }
          ]
      }
  }
  ```

###### url-loader

url-loader，主要用来将资源(图片、字体等)文件转换为 Data URL 的形式，Data URLs 是一种特殊的 url 协议，url 可以直接去表示文件内容的方式，也就是说，这种 URL 中的文本就已经包含了文件内容。在使用过程中，不会再去发送任何的 HTTP请求。如果要将图片、字体等二进制的文件进行编译时，会将文件的内容进行 base64 编码，然后以 base64编码 过后的结果（一个字符串）去表示文件的内容。

url-loader，适合转换体积比较小的文件资源。

* 1，安装 loader 模块

  ```powershell
  $ yarn add url-loader --dev # or npm i url-loader --save-dev
  ```

* 2，在 webpack.config.js 中进行配置

  <font color="#999999">配置代码如下（webpack.config.js）：</font>

  ```js
  module.exports = {
      module: {
          rules: [
              {
                  test: /\.png$/,
                  use: {
                      loader: 'url-loader',
                      options: { // 设置配置选项
                          limit: 10 * 1024 // 10 KB 单位字节，只匹配 10 KB 以下的
                      }
                  }
              }
          ]
      }
  }
  ```

  **建议**

  1）小文件使用 Data URLs，减少请求次数；

  2）大文件单独提取存放，提高加载速度。

  **注意**

  在对 url-loader 适合的文件大小进行限制后，需要同时安装 file-loader，避免超出大小限定的文件无法转换而引起报错的情况。

##### 导入资源模块

JavaScript 驱动整个前端应用的业务，因此需要把 打包入口 设置为 js 文件，它也相当于是 运行入口。在 js 代码中 通过 **import** 导入其他资源文件。

* 1，在 main.js 中引入 css 文件

  <font color="#999999">代码示例如下（main.js）：</font>

  ```js
  import createHeading from './heading.js'
  import './main.css'
  
  const heading = createHeading()
  document.body.append(heading)
  ```

* 2，在 webpack.config.js 中设置入口文件

  <font color="#999999">配置代码如下（webpack.config.js）：</font>

  ```js
  module.exports = {
      entry: './src/main.js' // 相对路径时，./ 不能省略
  }
  ```

  页面效果，如下图所示：

  ![image-20201127085018517](C:\Users\li_sh\AppData\Roaming\Typora\typora-user-images\image-20201127085018517.png)

  

  **注意**

  一般需要根据代码的需要动态导入资源，因为需要资源的不是应用，而是此时正在编写的代码。

  **优势**

  1）逻辑合理，JS 确实需要这些资源文件；

  2）确保上线资源不缺失，都是必要的。



基于模块化工具构建现代 Web 应用

打包工具的优化技巧



