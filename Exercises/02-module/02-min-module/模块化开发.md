@[TOC](模块化开发)

# 模块化概述

当下最重要的前端开发范式之一。模块化只是一个思想、一个理论。

内容概要

## 模块化演变过程

早期模块化完全依靠约定。

* 1，文件划分方式

  **缺点：**

  污染全局作用域

  命名冲突问题

  无法管理模块依赖关系

* 2，命名空间方式

  将所需变量包裹进全局对象内

* 3，IIFE

  将变量私有成员

## 模块化规范

模块化标准 + 模块加载器

### CommonJs 规范

CommonJs 是针对 NodeJs 的规范，是以同步模式加载模块，约定如下：

* 1，一个文件就是一个模块
* 2，每个模块都有单独的作用域
* 3，通过 module.exports 导出成员
* 4，通过 require 函数载入模块

### AMD + Require.js 

AMD(Asynchronous Module Definition)，异步的模块定义规范，是针对浏览器的规范，它是通过 Require.js 进行实现的，Require.js 是一个非常强大的模块加载器。

**缺点**

* 1，AMD 使用起来相对复杂；
* 2，模块 JS 文件请求频繁

#### Require.js API

##### define()

每一个模块都要通过 define() 函数进行定义。

* 传递三个参数

  第一个参数，是一个字符串，表示模块名，方便后期通过模块名进行使用；

  第二个参数，是一个数组，用来声明这个模块的一些依赖项，此参数按需添加，可有可无；

  第三个参数，是一个函数，函数的参数与前面数组中的依赖项一一对应，每一项分别为依赖项导出的成员，用来为当前模块提供私有空间，通过 return 向外部导出成员

  <font color="#999999">语法示例如下：</font>

  ```javascript
  define('module_name', [], function() { return ... })
  ```

##### require()

require() 函数，用来载入一个模块，内部会自动创建script标签，执行相应的代码。

* 传入两个参数

  第一个参数，是一个数组，表示所引入模块的组合

  第二个参数，是一个函数，函数的参数与前面数组中的模块一一对应，可以使用 **模块名.xx** 的方式访问模块中导出的成员

  <font color="#999999">语法示例如下：</font>

  ```javascript
  require(['module_name', ...], function(module_name){
     // module_name.xx 
  })
  ```

### CMD + Sea.js

CMD(Common Module Definition)，通用的模块定义规范，类似 CommonJs 规范。Sea.js 是由淘宝推出的库，遵循CMD规范。

### 模块化标准规范

模块化的最佳实践：NodeJs 环境遵循 CommonJs，浏览器环境遵循 ES Modules 规范。

#### ES Modules

ES Modules 规范 是在 ECMAScript2015(ES6)中提出的 Module 模块标准。通过给 script 添加 type = module 的属性，就可以以 **ES Module** 的标准执行其中的 JS 代码。

##### 基本特性

* 1，ESM 自动采用严格模式，忽略 'use strict' 

  ```html
  <script type="module">
      console.log(this); // undefined this在严格模式下，为 undefined
  </script>
  ```

* 2，每个 ES Module 都是运行在单独的私有作用域中

  ```html
  <script type="module">
      var foo = 100   // 不会造成全局作用域污染问题
      console.log(foo) // 100
  </script>
  <script type="module">
      console.log(foo) // Uncaught ReferenceError: foo is not defined
  </script>
  ```

* 3，ESM 是通过 CORS 的跨域请求方式请求外部 JS 模块的

  ```html
  <script type="module" src="https://umpkg.com/jquery@3.4.1/dist/jquery.min.js"> 		// 需要服务端支持 CORS ，否则会出现跨域问题
  </script>
  ```

- 4，ESM 的 script 标签会延迟执行脚本，相当于 script 的 defer 属性

  ```html
  <script type="module" src="./demo.js">
      // 等待网页的渲染过后，再去执行脚本，不会阻碍页面的显示
  </script>
  <p>需要显示的内容</p>
  ```

##### 导入和导出

###### 导出 (export)

export 是在模块内去对外暴露接口。

**导出语法**

* 1，**直接成员导出**，变量、函数、类等都可以导出。

  <font color="#999999">导出方式如下：</font>

  ```javascript
  export var name = 'foo module'   // 导出变量
  
  export function hello () { }     // 导出函数
  
  export class Person { }          // 导出类  
  ```

* 2，**成员集中导出**，可以更加直观的看到向外部导出了哪些成员

  导出方式如下：</font>

  ```javascript
  var name = 'foo module'
  function hello () { }
  class Person { }
  
  export { name, hello, Person }
  ```

* 3，**别名导出**，使用 as 进行重命名

  导出方式如下：</font>

  ```javascript
  var name = 'foo module'
  function hello () { }
  class Person { }
  
  export { name as fooName, hello as fooHello, Person as fooPerson }
  ```

* 4，**默认导出**，设置某一个成员的别名是 default

  导出方式如下：</font>

  ```javascript
  var name = 'foo module'
  
  export { name as default }
  // <==> 推荐下方书写方式
  export default name
  ```

###### 导入 (import)

import 是在模块内导入其他模块所提供的接口。

**导入语法**

对应上面的导出语法。

* 1，对应 **直接成员导出 和 成员集中导出**

  <font color="#999999">导入方式如下：</font>

  ```javascript
  import { name, hello, Person } from 'module_path' // .js 不可以省略，完整路径
  ```

* 2，对应 **别名导出**

  ```javascript
  import { fooName, fooHello, fooPerson } from 'module_path'
  ```

* 3，对应 **默认导出**

  ```javascript
  import { default as name }  from 'module_path' // default 是关键字
  // 简写为
  import name from 'module_path'
  ```

###### 注意事项

* 1，export 单独使用时， <font color="#ff0000">{}</font> 是固定语法，导出的不是对象字面量

  <font color="#999999">代码示例如下：</font>

  ```javascript
  var name = 'jack'
  var age = 18
  
  export { name, age } 
  ```

  导入模块，<font color="#ff0000">{}</font> 固定语法，不是对象的解构

  <font color="#999999">代码示例如下：</font>

  ```javascript
  import { name, age } from './module.js'
  ```

* 2，export default 组合使用时，<font color="#ff0000">{}</font> 代表导出的是对象字面量

  <font color="#999999">代码示例如下：</font>

  ```javascript
  var name = 'jack'
  var age = 18
  
  export default { name, age }
  ```

  导入模块，**不可以**使用 {} 写法

  <font color="#999999">代码示例如下：</font>

  ```javascript
  // module_obj 自定义名字，最好和模块名保持一致
  import module_obj from './module.js' 
  
  // 访问导出的成员
  console.log(module_obj.name, module_obj.age)
  ```

* 3，export 导出的是值的**内存地址**

  <font color="#999999">代码示例如下(module.js)：</font>

  ```javascript
  var name = 'jack'
  var age = 18
  
  export { name, age } // 导出的是值的内存地址
  
  setTimeout(function () {
      name = 'ben'
  }, 1000)
  ```

  <font color="#999999">代码示例如下(app.js)：</font>

  ```javascript
  import { name, age } from './module.js'
  
  console.log(name, age);  // jack 18
  
  setTimeout(function () {
      console.log(name, age); // ben 18
  }, 1500)
  ```

* 4，导出的值是只读的，无法在模块外部修改成员

  <font color="#999999">代码示例如下(app.js)：</font>

  ```javascript
  import { name, age } from './module.js'
  
  name = 'tom' // Uncaught TypeError: Assignment to constant variable.
  ```

* 5，导入模块时，模块路径的三种写法

  <font color="#999999"> 语法示例如下(app.js)：</font>

  ```javascript
  // ./ 不可以省略，相对路径
  import { name } from './module.js'
  
  // / 绝对路径
  import { name } from '/04-import/module.js'
  
  // 完整 url 路径
  import { name } from 'htto://localhost:3000//04-import/module.js'
  ```

  





常用的模块化打包工具

基于模块化工具构建现代 Web 应用

打包工具的优化技巧



