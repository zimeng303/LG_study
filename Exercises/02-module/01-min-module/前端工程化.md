@[TOC](前端工程化)

# 前言

# 前端工程化概述

### 工程化的定义和主要解决的问题

**定义**

前端工程化是指遵循一定的标准和规范，通过工具去提高效率，降低成本的一种手段。

**面临的问题**

1、想要使用 ES6 + 新特性，但是兼容有问题

2、想要使用 Less / Sass / PostCSS 增强 CSS 的编程性，但是运行环境不能直接支持

3、想要使用模块化的方式提高项目的可维护性，但运行环境不能直接支持

4、部署上线前需要**手动**压缩代码及资源文件，部署过程需要**手动**上传代码到服务器

5、多人协作开发，无法硬性统一大家的代码风格，从仓库中 pull 回来的代码质量无法保证

6、部分功能开发时，需要等待后端服务接口提前完成

**主要解决的问题**

1、传统语言或语法的弊端

2、无法使用模块化/组件化

3、重复的机械式工作

4、代码风格统一、质量保证

5、依赖后端服务接口支持

6、整体依赖后端项目

### 工程化的表现

一切以提高效率、降低成本、质量保证为目的的手段都属于**工程化**

* 一个项目过程中，工程化的具体表现

  ![](C:\Users\li_sh\Desktop\WebStudy\LaGou\Exercises\02-module\01-min-module\assets\image-20201116084944144.png)
  
  

一切重复的工作都应该被自动化

Web Server 热更新

Git Hooks -- 代码质量、代码风格的检查

CI / CD 

实现前端工程化可以从 模块化、组件化、规范化、自动化等方面出发。



### 工程化不等于工具

![工程化不等于工具](C:\Users\li_sh\Desktop\WebStudy\LaGou\Exercises\02-module\01-min-module\assets\image-20201116093411534.png)



一些成熟的工程化集成

create-react-app

vue-cli

angular-cli

gatsby-cli

### 工程化与 Node.js

**内容概要**

脚手架工具开发

自动化构建系统

模块化打包

项目代码规范化

自动化部署

# 脚手架工具

### #### 概要

简单来说，脚手架就是用来自动的去帮我们创建项目基础文件的一个工具。

脚手架工具，可以认为是前端工程化的发起者。

**脚手架的本质作用**

创建项目基础结构、提供项目规范和约定。

* 一般来说，一个项目中包含一些相同的约定，即：

  1）相同的组织结构

  2）相同的开发范式

  3）相同的模块依赖

  4）相同的工具配置

  5）相同的基础代码

我们可以通过脚手架工具搭建一个特定的项目骨架，然后基于这个骨架去进行相关的开发工作。

**前端脚手架**

以独立的工具存在，不会集成在IDE中。

#### 脚手架的作用

#### 常用的脚手架工具 

React项目 --> create-react-app

Vue 项目 --> vue-cli

Angular 项目 --> angular-cli

相同点：根据信息创建对应的项目基础结构，只适用于

##### 一、Yeoman

**特点**

灵活、容易扩展

**简介**

**优缺点**

**基本使用**

* **安装**

  全局安装，此处使用 yarn 命令，也可以使用 npm / cnpm

  ```cmd
  $ yarn global add yo  # or npm install yo --global
  ```

  Yeoman 需要搭配特定的 Generator 使用，在这里我们是使用的node_module，因此还需要全局安装 generator-node 

  ```cmd
  $ yarn global add generator-node # or npm install generator-node --global
  ```

  **注意**

  如果出现无法识别 yo 命令的问题，请查看[yarn的配置](https://blog.csdn.net/zimeng303/article/details/109716237)，里面详细讲述了解决方案。

* **通过 yo 运行 generator**

  使用 Yeoman 提供的 yo 命令，去运行 generator-node 生成器。运行特定的生成器，就是将 generator- 前缀去掉，直接使用 **yo** 运行后面的部分即可。

  ```cmd
  $ mkdir project-dir-name
  $ cd path/to/project-dir
$ yo node  
  ```
  
  执行结果如下：
  
  ![初始化模块](C:\Users\li_sh\Desktop\WebStudy\LaGou\Exercises\02-module\01-min-module\assets\image-20201116163119662.png)
  
  最终得到的项目结构，如图所示：
  
  ![目录结构](C:\Users\li_sh\Desktop\WebStudy\LaGou\Exercises\02-module\01-min-module\assets\image-20201116165207933.png)

**Sub Generator**

在已有的项目结构中，创建一些特定类型的文件，可以使用 Yeoman 提供的 **Sub Generator** 进行实现。

我们这里则可以使用 generator-node中提供的一个子集的生成器，即叫cli的生成器，它可以生成cli所需要的一些文件。

下面，我们使用这个 cli 生成器，将我们这个模块变成一个 cli 应用。

**语法**

 yo + generator的名字 + : + Sub Generator的名字

<font color="#999999">命令代码如下：

```cmd
$ cd path/to/project-dir
$ yo node:cli
```

执行结果如下：

![image-20201116225308658](C:\Users\li_sh\Desktop\WebStudy\LaGou\Exercises\02-module\01-min-module\assets\image-20201116170415750.png)

执行完上述的操作以后，我们就可以将我们这个模块作为全局的命令行模块进行使用

通过 yarn link 命令，连接到全局范围内。

```cmd
$ yarn link # or npm link
```

执行完上述命令后，会将 新的模块生成的依赖包，存放到 Yarn 应用程序的本地数据文件夹中。

![image-20201117090716854](C:\Users\li_sh\AppData\Roaming\Typora\typora-user-images\image-20201117090716854.png)

并且，会将新的模块的cmd脚本文件，注册到 yarn global bin 的路径下。

![image-20201117090415664](C:\Users\li_sh\Desktop\WebStudy\LaGou\Exercises\02-module\01-min-module\assets\image-20201117090415664.png)

此时还需要使用 yarn 命令，安装项目的全部依赖。

```cmd
$ yarn
```

**注意**

```通过yarn 安装的依赖，会在npm的 bin 目录下添加 cmd 执行脚本```，因此，在这里可能需要配置环境变量。

查看生成的 cmd 脚本文件，如果如下图，需要删除 **%~dp0**，否则无法找到 link 后的模块。

![脚本文件](C:\Users\li_sh\Desktop\WebStudy\LaGou\Exercises\02-module\01-min-module\assets\image-20201117094645389.png)

全局访问

```cmd
$ module-name --help
```

执行结果，如图所示：

![执行结果](C:\Users\li_sh\Desktop\WebStudy\LaGou\Exercises\02-module\01-min-module\assets\image-20201117095027384.png)

**注意**

并不是每一个 generator 都存在子集的生成器，需要以官方文档为准。

##### Yeoman 使用步骤总结

1、明确你的需求；

2、找到合适的 Generator；

3、全局范围安装找到的 Generator；

4、通过 Yo 运行对应的 Generator；

5、通过命令行交互填写选项；

6、生成你所需要的项目结构；



Plop：创建特定类型的文件，例如 创建一个组件 / 模块所需要的文件

### 自定义 Generator

基于 Yeoman 搭建自己的脚手架

##### 创建 Generator 模块

Generator 本质上就是一个 NPM 模块

###### Generator 基本结构

目录结构如下：

![image-20201117104717779](C:\Users\li_sh\Desktop\WebStudy\LaGou\Exercises\02-module\01-min-module\assets\image-20201117104717779.png)

如果想要创建Sub Generator，可以创建 component 文件夹，进行存放，目录结构如下：

![image-20201117104740639](C:\Users\li_sh\Desktop\WebStudy\LaGou\Exercises\02-module\01-min-module\assets\image-20201117104740639.png)

###### 自定义 Generator 的命名规范

generator-**<font color="#ff0000"><name></font>**

**注意**

如果命名不规范，那么后期 Yeoman 就无法找到所定义的 生成器模块。

###### 创建 Generator 步骤

* 一、创建 Generator 的文件夹，命名要符合命名规范，如 generator-sample

  ```cmd
  $ mkdir generator-sample
  ```

* 二、使用 yarn 或者 npm ，创建并初始化 package.json 文件

  ```cmd
  $ cd generator-sample
  $ yarn init # or npm init
  ```

* 三、安装 yeoman-generator 的模块，这个模块提供了生成器的一个基类，这个基类中提供了一些工具函数，使我们在创建 Generator 时更加便捷。

  ```cmd
  $ yarn add yeoman-generator # or npm install yeoman-generator 
  ```

* 四、根据上面的 Generator 基础目录，我们在 yeoman-generator 文件目录内，生成器的入口文件 index.js，目录结构如下：

  ![image-20201117112421095](C:\Users\li_sh\Desktop\WebStudy\LaGou\Exercises\02-module\01-min-module\assets\image-20201117112421095.png)

* 五，然后在入口文件index.js中，进行简单编写

  ```javascript
  // index.js : 此文件作为 Generator 的核心入口
  
  // 引入 yeoman-generator，以便可以使用其内部的基类，从而使用其工具函数...
  const Generator = require('yeoman-generator')
  
  // 导出一个继承自 Yeoman Generator 的类型
  module.exports = class extends Generator {
      writing () {
          // Yeoman 自动在生成文件阶段调用此方法
          // 我们这里尝试往项目目录中写入文件
          this.fs.write( // 通过父类中的fs模块进行写入，与 node中的不一样
              // 写入文件的绝对路径
              this.destinationPath('temp.txt'), // destinationPath 自动获取，生成项目目录下对应的文件路径
              Math.random().toString() // 写入文件内容
          )
      }
  
  }
  ```

  上述文件中，index.js 作为 Generator 的核心入口，需要导出一个继承自 Yeoman Generator 的类型。Yeoman Generator 在工作时，会自动调用我们在此类型中定义的一些生命周期方法，我们在这些方法中可以通过调用父类提供的一些工具方法，去实现一些功能，例如文件导入等。

* 六，通过 yarn link 或者 npm link 的方式，将自定义的 Generator 模块，链接到全局范围，使之成为一个全局模块包。

  ```cmd
  $ yarn link # or npm link
  ```

  我的 yarn 本地链接到的是在 C盘，如下图：

  ![image-20201117160537803](C:\Users\li_sh\AppData\Roaming\Typora\typora-user-images\image-20201117160537803.png)

  

* 七、新建项目目录，进入目录，执行 yeoman 操作

  ```cmd
  $ cd path/to/project-dir
  $ yo sample
  ```

  **注意**

  由于我的 yarn 本地链接到的是在 C盘，直接使用上面的操作会报出如下错误：

  ![image-20201117165840071](C:\Users\li_sh\AppData\Roaming\Typora\typora-user-images\image-20201117165840071.png)

  

  此时，有**两种解决方案**。

  

  **一、**将 link的 generator-sample **拷贝**到yarn的全局安装目录中，如下图所示：

  ![image-20201117160746020](C:\Users\li_sh\AppData\Roaming\Typora\typora-user-images\image-20201117160746020.png)

  

  **二、**在执行上述操作之前，先将 generator-sample 链接到当前文件夹下，命令如下：

  ```cmd
  $ cd path/to/project-dir
  $ yarn link generator-sample
  $ yo sample
  ```

  通过上面的操作，便可以使 Yeoman 找到这个 generator-sample 依赖包了。

  我个人推荐第二种。

  

  命令执行如下图所示：

  ![image-20201117161142970](C:\Users\li_sh\AppData\Roaming\Typora\typora-user-images\image-20201117161142970.png)

  执行后，会在项目目录下写入 temp.txt 文件，并在文件内写入 随机数内容，如图所示：

  ![image-20201117161316020](C:\Users\li_sh\AppData\Roaming\Typora\typora-user-images\image-20201117161316020.png)

##### 根据模板创建文件

* **模板文件的语法**

  模板文件内部可以使用 EJS 模板标记输出数据，如：

  ```javascript
  <%= title %>
  ```

  其他的 EJS 语法也支持，如：

  ```javascript
  <% if (success) { %>
  哈哈哈
  <% } %>
  ```

* **使用模板文件代替直接写入的方式**

  <font color="#999999">代码如下（index.js）：</font>

  ```javascript
  module.exports = class extends Generator {
      writing () {
          // Yeoman 自动在生成文件阶段调用此方法
          // 通过模板方式写入文件到目标目录
  
          // 模板文件路径
          const tmpl = this.templatePath('foo.txt')
  
          // 输出目标文件
          const output = this.destinationPath('foo.txt')
  
          // 输出数据上下文
          const context = { title: 'Hello zce~', success: false }
  
          this.fs.copyTpl(tmpl, output, context)
      }
  }
  ```

* **好处**

  相对于手动创建每一个文件，模板的方式大大提高了效率。

* **接收用户输入数据**

  在 Yeoman 当中，如何动态的接收用户输入数据？

  <font color="#999999">代码如下（index.js）：</font>

  ```javascript
  const Generator = require('yeoman-generator')
  
  module.exports = class extends Generator {
      prompting () {
          // Yeoman 在询问用户环节会自动调用此方法
          // 在此方法中可以调用父类的 prompt() 方法发出对用户的命令行询问
  
          // 接收一个数组参数，数组的每一项都是一个问题对象
          return this.prompt([ // 返回一个 Promise对象
              {
                  type: 'input', // 使用用户输入的方式，让用户提交信息
                  name: 'name',  // 最终得到结果的一个键
                  message: 'Your project name', // 在界面中给用户的提示，即问题
                  default: this.appname // appname 为项目生成目录名称
              }
          ]).then(answers => { //用户输入之后的结果
              // answers => { name:'user input value' }
              this.answers = answers // 便于writing时使用
          })
      }
      writing () {
          // Yeoman 自动在生成文件阶段调用此方法
  
          // 通过模板方式写入文件到目标目录
  
          // 模板文件路径
          const tmpl = this.templatePath('bar.html')
  
          // 输出目标文件
          const output = this.destinationPath('bar.html')
  
          // 输出数据上下文
          // 此时使用用户输入数据，作为模板文件的上下文
          const context = this.answers 
  
          this.fs.copyTpl(tmpl, output, context)
      }
  
  }
  ```

  在 templates 目录下面新建 bar.html，并使用 ESJ 模板引擎的写法。
  
  <font color="#999999"> 代码示例如下：</font>
  
  ![image-20201117234244083](C:\Users\li_sh\AppData\Roaming\Typora\typora-user-images\image-20201117234244083.png)
  
  其中的 **“name”** 为在index.js中 prompt() 方法中传入的数组参数元素中 name 的值。

### Vue Generator 案例

###### 创建步骤

###### 创建 Generator

* 一、先创建一个 generator-vue  的文件夹，并创建及初始化 package.json 包管理文件，以及安装 yeoman-generator 模块

  ```cmd
  $ mkdir generator-vue
  $ cd generator-vue
  $ yarn init # or npm init
  $ yarn add yeoman-generator # or npm install yeoman-generator -D
  ```

* 二、将 vue中生成的目录结构，拷贝到 Generator 中，使其作为模板文件存在，如图所示：

  ![image-20201118000602115](C:\Users\li_sh\AppData\Roaming\Typora\typora-user-images\image-20201118000602115.png)

* 三、依据上面的自定义 Generator 步骤，在 index.js 入口文件中，添加 prompting() 方法和writing()方法，prompting() 方法代码如上，下面我们只来书写 writing() 方法中的代码。

  <font color="#999999">代码示例如下：</font>

  ```javascript
  const Generator = require('yeoman-generator')
  
  module.exports = class extends Generator {
      prompting() {
          // ... , 代码同上
      }
  
      writing() {
          // 把每一个文件都通过模板转换到目标路径
  
          const templates = [
              '.browserslistrc',
              '.editorconfig',
              '.env.development',
              '.env.production',
              '.eslintrc.js',
              '.gitignore',
              'babel.config.js',
              'package.json',
              'postcss.config.js',
              'README.md',
              'public/favicon.ico',
              'public/index.html',
              'src/App.vue',
              'src/main.js',
              'src/router.js',
              'src/assets/logo.png',
              'src/components/HelloWorld.vue',
              'src/store/actions.js',
              'src/store/getters.js',
              'src/store/index.js',
              'src/store/mutations.js',
              'src/store/state.js',
              'src/utils/request.js',
              'src/views/About.vue',
              'src/views/Home.vue'
          ]
  
          templates.forEach(item => {
              // item => 每个文件路径
              
              // 使用fs的copyTpl() 方法，将每一个对应的模板生成到对应的文件
              this.fs.copyTpl(
                  this.templatePath(item),
                  this.destinationPath(item),
                  this.answers
              )
          })
  
      }
  }
  ```

* 使用 generator-vue 方法，同 自定义Generator 使用方法，执行结果如下：

  ![image-20201118001807827](C:\Users\li_sh\AppData\Roaming\Typora\typora-user-images\image-20201118001807827.png)

### 发布 Generator





















