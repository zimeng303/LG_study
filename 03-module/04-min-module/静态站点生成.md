@[TOC](静态站点生成)

# 静态网站生成器

**什么是静态网站生成器**

* 静态网站生成器是一系列配置、模板以及数据，生成静态 HTML 文件及相关资源的工具
* 这个功能也叫 **预渲染**
* 生成的网站不需要类似 **PHP** 这样的服务器
* 只需要放到支持静态资源的 **Web Server** 或 **CDN** 上即可运行

**静态网站的好处**

* 省钱
  * 不需要专业的服务器，只要能托管静态文件的空间即可
* 快速
  * 不经过后端服务器的处理，只传输内容
* 安全
  * 没有后端程序的运行，自然会更安全

**常见的静态网站生成器** 

* Jekyll（Ruby）
* Hexo（Node）
* Hugo（Golang）
* Gatsby（Node/React）
* Gridsome（Node/Vue）
* 另外，Next.js，Nuxt.js 也能生成静态网站，但是它们更多被认为是 SSR（服务端渲染）框架。

**JAMStack**

 **JAMStack**(静态网站生成器) 使您可以通过预渲染文件并直接从CDN直接提供文件来构建快速安全的站点和应用程序，而无需管理或运行Web服务器。

* 学习网站：[Learn more about the Jamstack](https://gridsome.org/docs/jamstack).
* JAMStack 的 JAM 是 JavaScript、API 和 Markup 的首字母组合
* 本质上是一种胖前端，通过调用各种 API 来实现更多的功能
* 其实也是一种前后端的模式，只不过离得比较开，甚至前后端来自多个不同的厂商

**静态应用的使用场景**

* 不适合有大量路由页面的应用
  * 如果您的站点有成百上千条路由页面，则预渲染将非常缓慢。当然，你每次更新只需要做一次，但是可能要花一些时间。大多数人不会最终获得数千条静态路由页面，而只是以防万一。
* 不适合有大量动态内容的应用
  * 如果渲染路线中包含特定于用户查看其内容或其动态源的内容，则应确保您具有可以显示的占位符组件，直到动态内容加载到客户端为止。否则可能有点怪异。

# Gridsome 基础

![image-20210120153314312](F:\LaGou\03-module\04-min-module\assets\image-20210120153314312.png)

## 基本介绍

**Gridsome 是什么**

- 一个免费、开源、基于 Vue.js 技术栈的静态网站生成器。
- 官方网站：[https://gridsome.org/](https://gridsome.org/)
- GitHub 仓库：[https://github.com/gridsome/gridsome](https://github.com/gridsome/gridsome)
- Gridsome 是由Vue.js驱动的Jamstack框架，用于构建默认情况下快速生成的静态生成的网站和应用。
- Gridsome是Vue提供支持的静态站点生成器，用于为任何无头CMS，本地文件或API构建可用于CDN的网站
- 使用Vue.js，webpack和Node.js等现代工具构建网站。通过npm进行热重载并访问任何软件包，并使用自动前缀在您喜欢的预处理器（如Sass或Less）中编写CSS。
- 基于 Vue.js 的 Jamstack 框架
- Gridsome 使开发人员可以轻松构建默认情况下快速生成的静态生成的网站和应用程序
- Gridsome允许在内容里面引用任何CMS或数据源。
  从WordPress，Contentful或任何其他无头CMS或API中提取数据，并在组件和页面中使用GraphQL访问它。

**为什么选择 Gridsome**

- **Vue.js for frontend** - The simplest & most approachable frontend framework.
- **Data sourcing** - Use any Headless CMSs, APIs or Markdown-files for data.
- **Local development with hot-reloading** - See code changes in real-time.
- **File-based page routing** - Any `Name.vue` file in `src/pages` is a static route.
- **Dynamic routing** - Any `[param].vue` file in `src/pages` is a dynamic route.
- **Static file generation** - Deploy securely to any CDN or static web host.
- **GraphQL data layer** - Simpler data management with a centralized data layer.
- **Automatic Code Splitting** - Builds ultra performance into every page.
- **Plugin ecosystem** - Find a plugin for any job.

**它是如何工作的**

Gridsome生成静态HTML，一旦加载到浏览器中，该HTML就会渗入Vue SPA。这意味着您可以使用Gridsome构建静态网站和动态应用程序。

Gridsome为每个页面构建一个.html文件和一个.json文件。加载第一页后，它仅使用.json文件来预取和加载下一页的数据。它还为需要它的每个页面构建一个.js包（代码拆分）。

它使用vue-router进行SPA路由，并使用vue-meta来管理<head>。

Gridsome默认添加最小57kB的gzip JS捆绑包大小（vue.js，vue-router，vue-meta和一些用于图像延迟加载的文件）。

[详细了解其工作原理](https://gridsome.org/docs/how-it-works)

**学习条件**

您应该具有有关HTML，CSS，Vue.js以及如何使用终端的基本知识。了解GraphQL的工作原理是有好处的，但不是必需的。 Gridsome是学习它的好方法。

Gridsome 需要Node.js（v8.3 +），并建议使用 Yarn。

**备选方案**

- [VuePress](https://vuepress.vuejs.org/)
- [Nuxt](https://nuxtjs.org/)
- [Gatsby.js](https://www.gatsbyjs.org/)

**使用场景**

- 不适合管理系统
- 简单页面展示
- 想要有更好的 SEO
- 想要有更好的渲染性能

## 基本使用

> 目标：快速了解 Gridsome 项目

* 1，安装 Gridsome CLI

  ```powershell
  # 使用 yarn
  yarn global add @gridsome/cli
  
  # 使用 npm
  npm install --global @gridsome/cli
  
  # 查看是否安装成功
  gridsome --version
  ```

* 2，创建 Gridsome 项目

  ```sh
  # 创建项目
  gridsome create my-gridsome-site
  
  # 进入项目中
  cd my-gridsome-site
  
  # 启动开发模式，或 npm run develop
  gridsome develop
  ```
  
  在创建项目时，自动安装依赖无法查看进度，如图所示：
  
  ![image-20210121102914706](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210121102914706.png)
  
  此时，可以中断进度，然后进入项目中，手动安装依赖：
  
  ```powershell
  # 进入项目中
  cd my-gridsome-site
  
  # 安装依赖
  npm install
  ```

> <font color="#f00">**gridsome 项目安装依赖注意事项：**</font>
>
> - 配置 node-gyp 编译环境
>   - [https://github.com/nodejs/node-gyp](https://github.com/nodejs/node-gyp)
>
> - 配置环境变量：`npm_config_sharp_libvips_binary_host` 为 `https://npm.taobao.org/mirrors/sharp-libvips/`
>   - [https://github.com/lovell/sharp-libvips](https://github.com/lovell/sharp-libvips)
>   - https://developer.aliyun.com/mirror/NPM
>   - https://npm.taobao.org/mirrors
>   - https://sharp.pixelplumbing.com/install
>     - `npm config set sharp_binary_host "https://npm.taobao.org/mirrors/sharp"`
>     - `npm config set sharp_libvips_binary_host "https://npm.taobao.org/mirrors/sharp-libvips"`
> - 配置 hosts：`199.232.68.133  raw.githubusercontent.com`
>   - https://www.ipaddress.com/

* 3，目录结构

* 

  ```bash
  .
  ├── src
  │   ├── components # 公共组件
  │   ├── layouts # 布局组件
  │   ├── pages # 页面路由组件
  │   ├── templates # 模板文件
  │   ├── favicon.png # 网站图标
  │   └── main.js # 应用入口
  ├── static # 静态资源存储目录，该目录中的资源不做构建处理
  ├── README.md
  ├── gridsome.config.js # 应用配置文件
  ├── gridsome.server.js # 针对服务端的配置文件
  ├── package-lock.json
  └── package.json
  ```

* 4，自己试一试

  * 在 `src/pages` 目录中创建一个 `.vue` 组件

* 5，构建

  ```bash
  gridsome build
  ```

  构建结果默认输出到 `dist` 目录中。

  `Gridsome` 会把每个路由文件构建为独立的 HTML 页面。

* 6，部署

  可以把构建结果 `dist` 放到任何 Web 服务器中进行部署。

  例如，我们这里使用 Node.js 命令行工具 [`serve`](https://github.com/vercel/serve) 来测试构建结果。

  ```bash
  # 安装 serve 部署静态网站
  npm install -g serve
  
  # 开始部署
  serve dist
  ```

  部署后的结果，如图所示：

  

  ![image-20210121114521060](F:\LaGou\03-module\04-min-module\assets\image-20210121114521060.png)

  访问浏览器，查看 `Network`，如图所示：

  

  ![image-20210121114659580](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210121114659580.png)

  或者可以部署到其它第三方托管平台：[https://gridsome.org/docs/deployment/](https://gridsome.org/docs/deployment/)。

  或是自己的服务器，都可以！

## 项目配置

Gridsome 需要 `gridsome.config.js` 才能工作。插件和项目设置位于此处。

*  `gridsome.config.js` ，基本配置文件如下所示：

  ```js
  module.exports = {
    siteName: 'Gridsome',
    siteUrl: 'https://www.gridsome.org',
    plugins: []
  }
  ```

  | 属性                     | 类型               | 默认值                | 说明                                                         |
  | ------------------------ | ------------------ | --------------------- | ------------------------------------------------------------ |
  | siteName                 | string             | `<dirname>`           | 该名称通常在标题标签中使用。                                 |
  | siteDescription          | string             | `''`                  | 页面描述，`<meta name="description" content="xxx">`          |
  | pathPrefix               | string             | `''`                  | Gridsome假定您的项目是从域的根目录提供的。如果您的项目将托管在名为my-app的子目录中，则将此选项更改为“ / my-app”。 |
  | titleTemplate            | string             | `%s - <siteName>`     | 设置标题标签的模板。 ％s占位符将替换为您在页面中设置的metaInfo的标题。 |
  | plugins                  | Array              | `[]`                  | 通过将插件添加到plugins数组来激活插件。                      |
  | templates                | object             | `{}`                  | 定义 `collections` 的路由和模板。                            |
  | metadata                 | object             | `{}`                  | 将全局元数据添加到GraphQL模式。                              |
  | icon                     | string \| object   | `'./src/favicon.png'` | Gridsome默认情况下会将位于src / favicon.png的任何图像用作favicon和touchicon，但您可以定义其他路径或大小等。图标应为正方形且至少16个像素。网站图标将调整为16、32、96像素。默认情况下，触摸图标的大小将调整为76、152、120、167、180像素。 |
  | configureWebpack         | object \| Function |                       | 如果该选项是一个对象，它将与内部配置合并。                   |
  | chainWebpack             | Function           |                       | 该函数将接收由 `webpack-chain` 驱动的 ChainableConfig 实例。 |
  | runtimeCompiler          | boolean            | false                 | 在运行时包括Vue模板编译器。                                  |
  | configureServer          | Function           |                       | 配置开发服务器。                                             |
  | permalinks.trailingSlash | boolean            | true                  | 默认情况下，在页面和模板后添加斜杠。启用此选项后，具有动态路由的页面将不包含尾部斜杠，并且服务器上必须具有额外的重写规则才能正常工作。另外，<g-link>的静态路径不会自动包含尾部斜杠，而应包含在路径中： |
  | permalinks.slugify       |                    |                       | 使用自定义的Slugify方法。默认是 [@sindresorhus/slugify](https://github.com/sindresorhus/slugify) |
  | css.split                | boolean            | false                 | 将CSS分成多个块。默认情况下禁用拆分。拆分CSS可能会导致奇怪的行为。 |
  | css.loaderOptions        | Object             | {}                    | 将选项传递给与CSS相关的 loader                               |
  | host                     | string             | localhost             | 访问地址                                                     |
  | port                     | number             | 8080                  | 端口号                                                       |
  | outputDir                | string             | `‘dist’`              | 运行gridsome构建时将在其中生成生产构建文件的目录。           |

  插件示例：

  ```js
  module.exports = {
      plugins: [
          {
              use: '@gridsome/source-filesystem',
              options: {
                  path: 'blog/**/*.md',
                  route: '/blog/:year/:month/:day/:slug',
                  typeName: 'Post'
              }
          }
      ]
  }
  ```

注意事项：

- 开发过程中修改配置需要**重启服务**

## Pages 页面

页面负责在URL上显示您的数据。每个页面将静态生成，并具有自己的带有标记的index.html文件。

在Gridsome中创建页面有两种选择：

- 单文件组件
- 使用 Pages API 以编程方式创建页面

**pages 中的单文件组件**

`src/pages` 目录中的单文件组件将自动具有其自己的URL。文件路径用于生成 URL，以下是一些基本示例：

- `src/pages/Index.vue` becomes `/`*(The frontpage)*
- `src/pages/AboutUs.vue` becomes `/about-us/`
- `src/pages/about/Vision.vue` becomes `/about/vision/`
- `src/pages/blog/Index.vue` becomes `/blog/`

> 大小自动转小写，驼峰命名会自动使用短横杠分割

src/pages 中的页面通常用于诸如 /about/ 之类的固定 URL，或用于在 /blog/ 等处列出博客文章。

**使用 Pages API 创建页面**

可以使用 `gridsome.server.js` 中的 `createPages` 钩子以编程方式创建页面。如果您要从外部 API 手动创建页面而不使用 GraphQL 数据层，则此功能很有用。

*  `gridsome.server.js` 

  ```js
  module.exports = function (api) {
      api.createPages(({ createPage }) => {
          createPage({
              path: '/my-page',
              component: './src/templates/MyPage.vue'
          })
      })
  }
  ```

**动态路由**

****

动态路由对于仅需要客户端路由的页面很有用。例如，根据URL中的细分从生产环境中的外部API获取信息的页面。

**通过文件创建动态路由**

动态页面用于客户端路由。可以通过将名称包装在方括号中来将路由参数放置在文件和目录名称中。例如：

- `src/pages/user/[id].vue` becomes `/user/:id`.
- `src/pages/user/[id]/settings.vue` becomes `/user/:id/settings`.

注意事项：

- 在构建时，这将生成 `user/_id.html` 和 `user/_id/settings.html`，并且您必须具有重写规则以使其正常运行。

- 具有动态路由的页面的优先级低于固定路由。例如，如果您有一个 `/user/create` 路由和 `/user/:id` 路由，则 `/user/create` 路由将具有优先级。

这是一个基本的页面组件，它使用路由中的id参数来获取客户端的用户信息：

* `user/[id].vue`

  ```html
  <template>
      <div v-if="user">
          <h1>{{ user.name }}</h1>
      </div>
  </template>
  
  <script>
      export default {
          data() {
              return {
                  user: null
              }
          },
          async mounted() {
              const { id } = this.$route.params
              const response = await fetch(`https://api.example.com/user/${id}`)
  
              this.user = await response.json()
          }
      }
  </script>
  ```

始终使用 `mounted` 来获取客户端数据。由于在生成静态HTML时执行数据，因此在 `created` 中获取数据会引起问题。

**通过编程方式创建动态路由**

以编程方式创建带有动态路由的页面，以获取更高级的路径。动态参数使用 `:` 来指定。

每个参数都可以具有一个自定义的正则表达式，以仅匹配数字或某些值。

* `gridsome.server.js`

  ```js
  module.exports = function (api) {
      api.createPages(({ createPage }) => {
          createPage({
              path: '/user/:id(\\d+)',
              component: './src/templates/User.vue'
          })
      })
  }
  ```

**生成重写规则**

Gridsome无法为动态路由的每种可能的变体生成HTML文件，这意味着直接访问URL时最有可能显示404页。而是，Gridsome生成一个HTML文件，该文件可用于重写规则。例如，类似/ user /：id的路由将生成位于 `/user/_id.html` 的HTML文件。您可以具有重写规则，以将所有与 `/ user /：id` 匹配的路径映射到该文件。

由于每种服务器类型都有自己的语法，因此必须手动生成重写规则。 afterBuild 挂钩中的 redirects 数组包含应生成的所有必要的重写规则。

* 示例代码，如下所示：

  ```js
  const fs = require('fs')
  
  module.exports = {
      afterBuild ({ redirects }) {
          for (const rule of redirects) {
              // rule.from   - The dynamic path
              // rule.to     - The HTML file path
              // rule.status - 200 if rewrite rule
          }
      }
  }
  ```

****

**页面 meta 信息**

* Gridsome 使用 [vue-meta](https://vue-meta.nuxtjs.org/) 处理有关页面的元信息。

  ```html
  <template>
      <div>
          <h1>Hello, world!</h1>
      </div>
  </template>
  
  <script>
      export default {
          metaInfo: {
              title: 'Hello, world!',
              meta: [
                  { name: 'author', content: 'John Doe' }
              ]
          }
      }
  </script>
  ```

**自定义 404 页面**

创建一个 `src/pages/404.vue` 组件以具有一个自定义 404 页面。

## Collections 集合

集合是一组节点，每个节点都包含带有自定义数据的字段。如果您要在网站上放置博客文章，标签，产品等，则集合很有用。

**添加集合**

****

集合可以通过 [source plugins](https://gridsome.org/plugins/) 添加，也可以使用 [Data Store API](https://gridsome.org/docs/data-store-api/) 自己添加。

在开发和构建期间，这些集合存储在本地内存数据存储中。节点可以来自本地文件（Markdown，JSON，YAML等）或任何外部API。

![Collections](F:\LaGou\03-module\resources\03-04-study-materials\handouts\3-4-2\assets\node-pages.0eae6d2.8581c59dbb258143a7ffcebb617ec5dc-7030007.png)

**使用 `source plugins` 添加集合**

将集合添加到 Gridsome 的最简单方法是使用源插件。本示例从 WordPress 网站创建集合。源插件的 typeName 选项通常用于为插件添加的集合名称添加前缀。

* `gridsome.config.js` ：

  ```js
  module.exports = {
      plugins: [
          {
              use: '@gridsome/source-wordpress',
              options: {
                  baseUrl: 'YOUR_WEBSITE_URL',
                  typeName: 'WordPress',
              }
          }
      ]
  }
  ```
  

你可以在[这里](https://gridsome.org/plugins)浏览插件列表。

**使用 `Data Store API` 添加集合**

您可以从任何外部 API 手动添加集合。

本示例创建一个名为 Post 的集合，该集合从 API 获取内容并将结果作为节点添加到该集合中。

* `gridsome.server.js`

  ```js
  const axios = require('axios')
  
  module.exports = function (api) {
      api.loadSource(async actions => {
          const collection = actions.addCollection('Post')
  
          const { data } = await axios.get('https://api.example.com/posts')
  
          for (const item of data) {
              collection.addNode({
                  id: item.id,
                  title: item.title,
                  content: item.content
              })
          }
      })
  }
  ```

  了解有关 [Data Store API](https://gridsome.org/docs/data-store-api/) 的更多信息。

****

## GraphQL数据层

![Import data](F:\LaGou\03-module\04-min-module\assets\import-data.eb9be63.3e0083b3c8c40a300ab593b006f88025.png)

**GraphQL数据层**是在开发模式下可用的工具。这是临时存储到 `Gridsome` 项目中的所有数据的地方。可以将其视为可帮助您更快更好地处理数据的本地数据库。

来自 GraphQL 数据层的数据将生成为静态内容。

数据层和导入数据的源之间没有实时连接。这意味着您需要重新生成网站以获取最新的数据更新。

如果需要动态数据，则应使用[客户端数据](https://gridsome.org/docs/client-side-data/)。

> 提示：默认情况下，Pages 也 Site metadata 已添加到数据层。

**GraphQL 中的集合**

* 开发环境，启动服务，暴露出数据层地址，只有开发环境可访问，如图所示：

  ![image-20210121155918781](F:\LaGou\03-module\04-min-module\assets\image-20210121155918781.png)

每个集合将向 [GraphQL schema](https://gridsome.org/docs/data-layer/) 添加两个根字段，这些根字段用于检索页面中的节点。

字段名称是根据集合名称自动生成的。如果您将集合命名为 Post，那么在架构中将具有以下可用字段：

- `post` 通过 `ID` 获取单个节点。
- `allPost` 获取节点列表（可以排序和过滤等）。

**自动生成 schema**

![image-20210121160304589](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210121160304589.png)

**处理数据**

- [How to import data](https://gridsome.org/docs/fetching-data/).
- [How to query data](https://gridsome.org/docs/querying-data/).
- [How to filter data](https://gridsome.org/docs/filtering-data/).
- [How to create taxonomy pages](https://gridsome.org/docs/taxonomies/).
- [How to paginate data](https://gridsome.org/docs/pagination/).
- [How to add client-side / dynamic data](https://gridsome.org/docs/client-side-data/).

**在 `GraphQL` 中查询数据**

* 查询语句，示例如下：

  ```js
  # 通过 ID 获取单个节点
  # query {
  #   post(id: 2) {
  #     id
  #     title
  #     content
  #   }
  # }
  
  # 获取节点列表
  query {
      allPost {
          edges {
              node {
                  id
                  title
              }
          }
      }
  }
  ```

* 查询结果，如下所示：

  ![image-20210121163145862](F:\LaGou\03-module\04-min-module\assets\image-20210121163145862.png)

**在页面中查询 `GraphQL`**

将数据从`GraphQL` 数据层查询到任何页面，模板或组件中。在Vue组件中，使用 `<page-query>` 或 `<static-query>` 块添加查询。

- 在 Pages 和 Templates 中使用 `<page-query>`

- 在 Components 中使用 `<static-query>``

- `pages/posts.vue`

  ```html
  <template>
    <Layout>
        <div>
            <h1>Posts2</h1>
            <ul>
                <li v-for="edge in $page.posts.edges" :key="edge.node.id">
                    <!-- 类似 router-link -->
                    <g-link to="/">{{ edge.node.title }}</g-link>
                </li>
            </ul>
        </div>
    </Layout>
  </template>
  
  <page-query>
      query {
        posts: allPost {
          edges {
            node {
              id
              title
            }
          }
        }
      }
  </page-query>
  ```

  此数据是通过 **预渲染 静态化** 出来的。

**分析总结**

**使用 GraphQL，您仅查询所需的数据。**这使得处理数据更加容易和整洁。

- 查询总是从 `query` 开始
- 然后是 `Posts`（可以是任何东西）
- 然后写一些内容例如 `posts: allWordPressPost`。
- `allWordPressPost` 是您要查询的GraphQL集合的名称。 
- `posts:` 部分是可选的别名。
- 使用 `posts` 作为别名时，您的数据将位于 `$page.posts`（如果使用 `<static-query>`，则为 `$static.posts`）。否则，它将在 `$page.allWordPressPost` 上可用。

**探索可用的类型和字段**

您可以通过在 [GraphQL 资源管理器](https://gridsome.org/docs/data-layer#the-graphql-explorer)中打开架构选项卡来浏览可用字段。

阅读有关如何在 GraphQL 中查询节点的更多信息：[https://gridsome.org/docs/querying-data/](https://gridsome.org/docs/querying-data/)。

## Templates

模板用于为集合中的节点创建单个页面。节点需要相应的页面才能显示在其自己的URL上。

**设置模板**

* 在 `src/templates` 目录下，创建 `Post.vue` 模板

  ```html
  <template>
    <Layout>
      <div>
          <h1>Post Page</h1>
      </div>
    </Layout>
  </template>
  
  <script>
  export default {
    name: "PostPage",
  };
  </script>
  
  <style>
  </style>
  ```

* 在 `gridsome.config.js` 中，配置模板选项

  ```js
  module.exports = {
      siteName: '拉勾教育',
      siteDescription: '大前端',
      plugins: [],
      templates: { // 配置模板
          Post: [
              {
                  // id 表示数据中存在的真实有效的字段
                  path: '/posts/:id',
                  component: './src/templates/Post.vue'
              }
          ]
      }
  }
  ```

**将数据添加到模板**

*  `src/templates/Post.vue` ，使用 `<page-query>` 添加查询，将数据设为动态的

  ```html
  <template>
    <Layout>
      <div>
        <h1>{{ $page.post.title }}</h1>
        <div>{{ $page.post.content }}</div>
      </div>
    </Layout>
  </template>
  
  <page-query>
  query ($id: ID!) {
    post(id: $id) {
      id
      title
      content
    }
  }
  </page-query>
  
  <script>
  export default {
    name: "PostPage",
  };
  </script>
  ```

> <font color="#f00">注意：</font>
>
> query ($id: ID!) {} ：
>
> * id ：指的是在 `gridsome.config.js` 中配置模板时填写的动态路由 `:id`；
> * ID! ：是指 对应字段 ID，并且是非空的

**节点字段作为 meta info**

* 在 `src/templates/Post.vue` 中，配置 `metainfo`

  ```html
  <script>
      export default {
          name: "PostPage",
          // 无法访问 page-query
          // metaInfo: {
          //   title: 
          // }
          metaInfo () {
              return {
                  title: this.$page.post.title
              }
          }
      };
  </script>
  ```

# 内容管理系统

内容管理系统，简称 CMS

## Strapi 

### 基本介绍

Strapi是一种灵活的开源 **内容管理平台(CMS)，**它使开发人员可以自由选择自己喜欢的工具和框架，同时还允许编辑人员轻松地管理和分发其内容。通过使管理面板和API可以通过插件系统进行扩展，Strapi 使全球最大的公司可以加速内容交付，同时构建优美的数字体验。

* 官网地址：[https://strapi.io/

### 基本使用

* 1，安装Strapi，并创建一个新项目

```powershell
yarn create strapi-app my-project --quickstart
```

* 2，创建一个管理员用户

  * 导航到[**http：// localhost：1337 / admin** （在新窗口中打开）](http://localhost:1337/admin)。

  * 完成表单以创建第一个**管理员**用户。

    ![image-20210122111511784](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122111511784.png)

* 3，创建文章内容类型（**Collection**）

  * 导航到[**PLUGINS** -**内容类型生成器** （在新窗口中打开）](http://localhost:1337/admin/plugins/content-type-builder)，在左侧菜单中。

  * 点击**“ +创建新的收藏夹类型”**链接

    ![image-20210122111439973](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122111439973.png)

  * 输入`Post`，然后单击`Continue`(继续)

    ![image-20210122111619718](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122111619718.png)

  * 点击**“ +添加其他字段”**按钮

    ![image-20210122111711424](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122111711424.png)

  * 单击**文本**字段

  * 键入`title`在**名称**字段

    ![image-20210122111859047](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122111859047.png)

  * 单击转到“**高级设置”**选项卡，然后检查`Required field`（必须的）和`Unique field`（唯一的）

    ![image-20210122111946597](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122111946597.png)

  * 点击**“ +添加另一个字段”**按钮

  * 单击**富文本格式**字段

  * 在“**名称”**字段content的“**基本设置”**选项卡下键入

  * 请点击 `Finish`

  * 单击**保存**按钮，然后等待Strapi重新启动

    ![image-20210122112243359](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122112243359.png)

* 4，创建 Collection Post 中的数据

  * **增加新的 Posts**

    ![image-20210122112820278](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122112820278.png)

  * 填写内容，点击**保存**

    ![image-20210122113014659](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122113014659.png)

  * 保存完后，会自动刷新，要求将接口权限开放 `Publish`

    ![image-20210122115628588](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122115628588.png)

    > <font color="#f00">注意：</font>
    >
    > 如果不点击 Public 的话，则将不能在外部访问到接口数据。
    >
    > <font color="#f00">一定要向外 Public ！！！</font>
    >
    > <font color="#f00">一定要向外 Public ！！！</font>
    >
    > <font color="#f00">一定要向外 Public ！！！</font>

  * 最后，形成的数据列表

    ![image-20210122120047240](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122120047240.png)

### 使用 Strapi 接口数据

#### 配置 角色 & 权限

* 点击 **设置-角色权限**

  ![image-20210122113631304](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122113631304.png)

* 点击 **编辑**，给 `Public` 公共用户，开放权限

  ![image-20210122113934126](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122113934126.png)

* 点击 **保存**

* **注意：**给 `Authenticated` 管理员用户，开放全部权限。

  ![image-20210122122523295](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122122523295.png)

#### Postman 测试接口

* 查询全部数据

  ![image-20210122120151152](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122120151152.png)

* 根据 `id` 进行精准匹配，查询数据

  ![image-20210122120234246](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122120234246.png)

### 访问受保护的 API

#### 添加用户数据

* 点击 **用户 - +增加新的 Users**

  ![image-20210122120651327](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122120651327.png)

* 填写用户相关信息，点击 **保存**

  ![image-20210122123110664](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122123110664.png)

#### Postman 测试

* 登录刚才添加的用户，拿到 `token`

  ![image-20210122123258809](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122123258809.png)

* 由此可以得到 `Token`，配置请求头

  ![image-20210122123741977](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122123741977.png)

> <font color="#f00">注意：</font>
>
> ​	这里使用了 Postman 进行接口的测试，具体的代码操作，参考官方网址：
>
> * [https://strapi.io/documentation/developer-docs/latest/plugins/users-permissions.html#concept](https://strapi.io/documentation/developer-docs/latest/plugins/users-permissions.html#concept)

# Gridsome 案例

## 案例介绍

* 使用第三方案例模板，嵌入到本次项目中

* 模板地址：[https://github.com/zimeng303/startbootstrap-clean-blog](https://github.com/zimeng303/startbootstrap-clean-blog)

  * 为防止项目作者的一些删除操作，建议将其 `Fork` 到自己的仓库中

* 使用 git 将其下载到本地，`--depth=1` 表示下载最后一次更新的代码

  ```powershell
  git clone git@github.com:zimeng303/startbootstrap-clean-blog.git --depth=1
  ```

## 基础实现

### 创建项目

* 使用 `gridsome` 创建项目

  ```powershell
  # 创建项目
  gridsome create #项目名称
  
  # 进入项目
  cd #项目名称
  
  # 启动项目(开发模式)
  npm run develop
  ```

### 基础配置

根据  `startbootstrap-clean-blog/index.html`，处理首页模板

* 安装相关依赖

  ```powershell
  npm i bootstrap @fortawesome/fontawesome-free
  ```

* 在 `src/main.js` 中，引入样式文件

  ```js
  import 'bootstrap/dist/css/bootstrap.min.css'
  import '@fortawesome/fontawesome-free/css/all.min.css'
  import '~/assets/css/index.css'
  ```

* 在 `src` 目录下，创建 `assets/css/index.css` 文件，用于引入字体文件和书写样式

  ```css
  @import url('https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic');
  @import url('https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800');
  
  /* 将 startbootstrap-clean-blog/css/clean-blog.css 中的内容复制到下方 */
  ```

### 公共模板

* 每个页面的 头部和底部都是一样的，只有中间部分不一样，因此将其公共部分提取出来

* 将 `startbootstrap-clean-blog/index.html` 的 `body` 部分的 `Navigation` 和 `Footer` 内容，复制到 `src/layout/Default.vue` 中

* `src/layout/Default.vue`，全局组件

  ```html
  <template>
      <div class="layout">
  
          <!-- Navigation -->
          <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
              ......
          </nav>
  
          <!-- 默认插槽 -->
          <slot/>
  
          <hr />
  
          <!-- Footer -->
          <footer>
              ......
          </footer>
      </div>
  </template>
  
  <style>
  </style>
  ```

### 首页模板

* 将 `startbootstrap-clean-blog/index.html` 的 `body` 部分的 `Page Header` 和 `Main Content` 内容，复制到 `src/pages/index.vue` 中

  * `src/pages/index.vue` ，创建根节点
  * 将 `startbootstrap-clean-blog/img` 目录拷贝到 `static` 目录下，并修改 url 路径，如下所示：

  ```html
  <template>
      <Layout>
          <!-- Page Header -->
          <header class="masthead" style="background-image: url('/img/home-bg.jpg')">
            ......
          </header>
  
          <!-- Main Content -->
          ......
      </Layout>
  </template>
  ```

  * 其他页面模板，与首页模板相似

### 管理 md 数据

使用第三方插件管理文件，从而可以将 **本地md文件中的内容** 读取到 **Graph QL 数据层** 中

* 安装插件

  ```powershell
  npm install @gridsome/source-filesystem
  ```

* 在 `gridsome.config.js` 中，配置插件，并创建对应路径的 md 文件

  ```js
  module.exports = {
      plugins: [
          {
              use: '@gridsome/source-filesystem',
              options: {
                  typeName: 'BlogPost',
                  // 抓取文件的路径，即抓取哪些文件
                  path: './content/blog/**/*.md',
              }
          }
      ]
  }
  ```

* `npm run develop`，启动服务，报出如下错误：

  ![image-20210122103446417](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122103446417.png)

  提示我们，没有安装转换 `markdown` 的转换器，即 `@gridsome/transformer-remark`

* 安装 `@gridsome/transformer-remark` 插件，它将 md 文件 转换为 HTML 文件

  ```powershell
  npm install @gridsome/transformer-remark
  ```

* 生成的数据格式，如图所示：

  ![image-20210122104450415](F:\LaGou\03-module\04-min-module\assets\image-20210122104450415.png)

## 预取数据

### 通过 GraphQL 访问 Strapi

* 参考网址：[https://strapi.io/documentation/developer-docs/latest/plugins/graphql.html](https://strapi.io/documentation/developer-docs/latest/plugins/graphql.html)

**基本使用**

* 安装 `graphql` 插件

  ```powershell
  yarn strapi install graphql
  ```

* 启动项目，访问 [http://localhost:1337/graphql](http://localhost:1337/graphql)

  ```powershell
  npm run develop
  ```

  ![image-20210122124723213](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122124723213.png)

### 将 Strapi 数据预取到 Gridsome

借助于 gridsome 的插件，将 Strapi 数据集成到 gridsome 中

* 安装 `@gridsome/source-strapi` 插件

  ```powershell
  npm install @gridsome/source-strapi
  ```

* 在 `gridsome.config.js` 文件中，配置插件信息

  ```js
  module.exports = {
      plugins: [
          {
              use: '@gridsome/source-filesystem',
              options: {
                  typeName: 'BlogPost',
                  // 抓取文件的路径，即抓取哪些文件
                  path: './content/blog/**/*.md',
              }
          },
          {
              use: '@gridsome/source-strapi',
              options: {
                  apiURL: 'http://localhost:1337', // 接口地址
                  queryLimit: 1000, // Defaults to 100
                  contentTypes: ['post'], // 查询的数据类型
                  // singleTypes: ['impressum'], // 单个节点
                  // Possibility to login with a Strapi user,
                  // when content types are not publicly available (optional).
                  // loginData: { // 登录信息
                  //   identifier: '',
                  //   password: ''
                  // }
              }
          }
      ],
  }
  ```

* 重新启动服务，访问 [http://localhost:8080/___explore](http://localhost:8080/___explore)

  ![image-20210122130130447](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122130130447.png)
  
  > <font color="#f00">注意：</font>
  >
  > ​	若 `Strapi` 中数据等被改变，必须重启 `Strapi` 项目，否则新数据无法同步预取到 `Gridsome` 中

## 具体实现

### 设计文章和标签数据模型

* 设计文章的字段，如图所示：

  ![image-20210122140410399](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122140410399.png)

* 设计标签时，需创建一个 `引用` 字段，用于表示 标签和文章的关系

  ![image-20210122135835788](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122135835788.png)

* 标签字段列表，如图所示：

  ![image-20210122140618790](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122140618790.png)

  > <font color="#f00">注意：</font>
  >
  > ​	标签的数据也要向外暴露 Public，否则，无法访问

  ![image-20210122154412203](C:\Users\86135\AppData\Roaming\Typora\typora-user-images\image-20210122154412203.png)

### 展示文章列表

* 在 `pages/index.vue` 中，从 GraphQL 数据层 获取数据，进行页面数据动态渲染

  ```html
  <template>
      <Layout>
          <!-- Main Content -->
          <div class="container">
              <div class="row">
                  <div class="col-lg-8 col-md-10 mx-auto">
                      <div class="post-preview" v-for="edge in $page.posts.edges" :key="edge.node.id">
                          <a href="post.html">
                              <h2 class="post-title">
                                  {{ edge.node.title }}
                              </h2>
                          </a>
                          <p class="post-meta">
                              Posted by
                              <a href="#">Start Bootstrap</a>
                              on {{ edge.node.create_at }}
                          </p>
                          <p>
                              <span v-for="tag in edge.node.tags" :key="tag.id">
                                  <g-link :to="'/tags/' + tag.id">
                                  	{{ tag.title }}
                                  </g-link>
                              </span>
                          </p>
  
                          <hr />
                      </div>
  
                      <!-- Pager -->
                  </div>
              </div>
          </div>
      </Layout>
  </template>
  
  <page-query>
   query {
      posts: allStrapiPosts {
      	edges {
      		node {
      			id
      			title  
      			created_at
      			tags {
      				id
      				title
      			}
      		} 
      	}
      }
  }
  </page-query>
  ```

### 文章列表分页

* 参考网址：[https://gridsome.org/docs/pagination/](https://gridsome.org/docs/pagination/)

* 使用 `Gridsome` 的 `@paginate` 指令，进行分页

* `pages/index.vue`，分页的具体实现

  ```html
   <!-- Pager -->
  <Pager :info="$page.posts.pageInfo" />
  
  <page-query>
  query ($page: Int) {
      posts: allStrapiPosts (perPage: 1, page: $page) @paginate {
          pageInfo {
              totalPages
              currentPage
          }
          edges {
              node {
                  id
                  title  
                  created_at
                  tags {
                      id
                      title
                  }
              } 
          }
      }
  }
  </page-query>
  
  
  <script>
  
  // 引入分页组件
  import { Pager } from 'gridsome'
  
  export default {
    components: {
      Pager
    }
  };
  </script>
  ```

### 展示文章详情

* 在 `gridsome.config.js` 中，配置模板

  ```js
  module.exports = {
      templates: { // 配置模板
          // StrapiPost 表示 gridsome/source-strapi 插件生成的 
          // 集合名称：typeName + contentTypes
          StrapiPosts: [
              {
                  path: '/posts/:id',
                  component: './src/templates/Post.vue'
              }
          ]
      }
  }
  ```

* `./src/templates/Post.vue`，具体实现

  ```html
  <template>
      <Layout>
          <!-- Page Header -->
          <header 
                  class="masthead" 
                  :style="{
                          backgroundImage: `url(http://localhost:1337${$page.post.cover.url})`
                          }"
                  >
              <div class="overlay"></div>
              <div class="container">
                  <div class="row">
                      <div class="col-lg-8 col-md-10 mx-auto">
                          <div class="post-heading">
                              <h1>{{ $page.post.title }}</h1>
                          </div>
                      </div>
                  </div>
              </div>
          </header>
  
          <!-- Post Content -->
          <article>
              <div class="container">
                  <div class="row">
                      <div 
                           class="col-lg-8 col-md-10 mx-auto" 
                           v-html="$page.post.content"
                      >            
                      </div>
                  </div>
              </div>
          </article>
      </Layout>
  </template>
  
  
  <page-query>
  query ($id: ID!) {
      post: strapiPosts (id: $id) {
          id
          title  
          content
          cover {
          	url
          }
          tags {
              id
              title
          }
      }
  }
  </page-query>
  ```

### 处理 md 文件

* 参考网址：[https://github.com/markdown-it/markdown-it](https://github.com/markdown-it/markdown-it)

* 借助 `markdown-it` 插件，将 md 格式的文件，转换为 HTML

* 安装 `markdown-it` 插件

  ```powershell
  npm install markdown-it --save
  ```

* 将插件加载进来，进行转换

  ```html
  <div class="col-lg-8 col-md-10 mx-auto" v-html="mdToHtml($page.post.content)">     
  
  <script> 
  import MarkdownIt from 'markdown-it'
  const md = new MarkdownIt()
  
  export default {
    methods: {
      mdToHtml (markdown) {
        return md.render(markdown)
      }
    }
  };
  </script>
  ```

### 文章标签

* 类似于 `Post.vue` 页面

### 处理基本设置





